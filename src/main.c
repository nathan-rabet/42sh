#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

#include "lexer.h"

#define BUFFER_SIZE 1024

/// Parser /////////////

struct Node
{
  char *type;
  char **words;
  int num_words;
};

struct Node *parse_simple_command(char *input)
{
    token *token = get_tokens(
        input, strlen(input)); // call the lexer's get_next_token function
    struct Node *node = malloc(sizeof(struct Node));
    node->type = "SIMPLE_COMMAND";
    node->words = malloc(sizeof(char *));
    node->words[0] = token->value;
    node->num_words = 1;

    while ((token = get_tokens(input, strlen(input))) != NULL)
    { // use the NULL token value from the lexer
        node->words =
            realloc(node->words, (node->num_words + 1) * sizeof(char *));
        node->words[node->num_words++] = token->value;
    }

  return node;
}

/// Execution module using execvp with wait /////////////
int execute_simple_command(struct Node *node)
{
  pid_t pid = fork();
  if (pid == 0)
  {
    execvp(node->words[0], node->words);
    perror("execvp");
    exit(1);
  }
  else
  {
    int status;
    waitpid(pid, &status, 0);
    return WEXITSTATUS(status);
  }
}

/// Parser printer /////////////
void parser_print(struct Node *node) {
  if (node == NULL) {
    return;
  }

  printf("Node type: %s\n", node->type);
  printf("Number of words: %d\n", node->num_words);
  printf("Words: ");
  for (int i = 0; i < node->num_words; i++) {
    printf("%s ", node->words[i]);
  }
  printf("\n\n");
}

/// main /////////////
int main(int argc, char *argv[])
{
  int opt;
  opterr = 0; // deletes the error line generated by getopt function as we handle the error on the default case
  bool input_from_stdin = true;
  char *input_string = NULL;
  char input_stdin[BUFFER_SIZE];

  // Parse command-line options
  while ((opt = getopt(argc, argv, "c:")) != -1)
  {
    switch (opt)
    {
    case 'c':
      // Read input from string
      input_from_stdin = false;
      input_string = optarg;
  
      // send the input_string to the lexer & parser
      struct Node *node = parse_simple_command(input_string);

      parser_print(node); //debug

      int status = execute_simple_command(node);
      printf("Command exited with status %d\n", status); // debug

      break;
    default:
      // Invalid option
      fprintf(stderr, "Error: Invalid option '%c'\n", optopt);
      fprintf(stderr, "Usage: %s [OPTIONS] [SCRIPT] [ARGUMENTS ...]\n", argv[0]);
      exit(2);
    }
  }

  // If no input source was specified, check if a file was given as a positional argument
  if (input_from_stdin)
  {
    if (optind < argc)
    {
      // Read input from file
      input_from_stdin = false;

      // Open file
      const char *filename = argv[optind];
      FILE *fp = fopen(filename, "r");
      if (!fp)
      {
        fprintf(stderr, "Error opening file\n");
        exit(2);
      }

      // Allocate memory for file contents
      char *file_contents = malloc(BUFFER_SIZE);
      if (file_contents == NULL)
      {
        fprintf(stderr, "Error: Failed to allocate memory\n");
        exit(2);
      }

      // Read file contents line by line and store them in the string file_contents
      char *line = NULL;
      size_t len = 0;
      while ((getline(&line, &len, fp)) != -1)
      {
        strcat(file_contents, line);
      }

      // send the file_contents to the lexer & parser
      struct Node *node = parse_simple_command(file_contents);

      parser_print(node); //debug

      int status = execute_simple_command(node);
      printf("Command exited with status %d\n", status); // debug

      // Free memory
      free(line);
      // Close file
      fclose(fp);
    }
  }

  // If no input source was specified, read from standard input
  if (input_from_stdin)
  {
    if (fgets(input_stdin, BUFFER_SIZE, stdin) == NULL)
    {
      fprintf(stderr, "Error: Failed to read input\n");
      exit(2);
    }

    // print stdin input (debug)
    printf("reading from stdin:\n %s", input_stdin);

      // send the input_string to the lexer & parser
      struct Node *node = parse_simple_command(input_stdin);

      parser_print(node); //debug

      int status = execute_simple_command(node);
      printf("Command exited with status %d\n", status); // debug
  }

  return 0;
}
