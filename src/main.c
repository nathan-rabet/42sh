#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

#include "./include/ast.h"
#include "./include/execution.h"
#include "./include/lexer.h"
#include "./include/parser.h"

#define BUFFER_SIZE 4096

int main(int argc, char *argv[])
{
    int opt;
    opterr = 0; // deletes the error line generated by getopt function as we
                // handle the error on the default case
    bool input_from_stdin = true;
    char *input_string = NULL;
    char input_stdin[BUFFER_SIZE];

    // Parse command-line options
    while ((opt = getopt(argc, argv, "c:")) != -1)
    {
        switch (opt)
        {
        case 'c':
            // Read input from string
            input_from_stdin = false;
            input_string = optarg;

            size_t input_size = strlen(input_string);

            // send the input_string to the lexer & parser
            xalloc_init();
            struct token *input_tokens = get_tokens(input_string, input_size);
            struct ast *ast = parser_input(input_tokens);
            // ast->vtable->pretty_print(ast);
            int status = ast->vtable->run(ast);
            if (status != 0)
            {
                xalloc_deinit();
                exit(status);
            }
            xalloc_deinit();

            break;

        default:
            // Invalid option
            fprintf(stderr, "Error: Invalid option '%c'\n", optopt);
            fprintf(stderr, "Usage: %s [OPTIONS] [SCRIPT] [ARGUMENTS ...]\n",
                    argv[0]);
            exit(2);
        }
    }

    // If no input source was specified, check if a file was given as a
    // positional argument
    if (input_from_stdin)
    {
        if (optind < argc)
        {
            // Read input from file
            input_from_stdin = false;
            // Open file
            const char *filename = argv[optind];
            FILE *fp = fopen(filename, "r");
            if (!fp)
            {
                fprintf(stderr, "Error opening file\n");
                exit(2);
            }
            xalloc_init();
            // Allocate memory for file contents
            char *file_contents = xmalloc(BUFFER_SIZE, sizeof(char));
            memset(file_contents, 0, BUFFER_SIZE); // zero the memory

            // Read file contents line by line and store them in the string
            // file_contents
            char *line = NULL;
            size_t len = 0;
            size_t file_contents_size = 0;
            while ((getline(&line, &len, fp)) != -1)
            {
                // Reallocate memory for file_contents
                file_contents = xrealloc(file_contents,
                                         file_contents_size + strlen(line) + 1,
                                         sizeof(char));
                file_contents_size += strlen(line);
                strncat(file_contents, line, strlen(line));
            }
            // send the file_contents to the lexer & parser
            struct token *input_tokens =
                get_tokens(file_contents, file_contents_size);
            struct ast *ast = parser_input(input_tokens);
            int status = ast->vtable->run(ast);
            if (status != 0)
            {
                xalloc_deinit();
                exit(status);
            }
            xalloc_deinit();

            // Free memory
            free(line);
            // Close file
            fclose(fp);
        }
    }

    // If no input source was specified, read from standard input
    if (input_from_stdin)
    {
        if (fgets(input_stdin, BUFFER_SIZE, stdin) == NULL)
        {
            fprintf(stderr, "Error: Failed to read input\n");
            exit(2);
        }
        if (input_stdin[0] == '\n')
            exit(2);
        size_t input_size = strlen(input_stdin);
        xalloc_init();
        struct token *input_tokens = get_tokens(input_stdin, input_size);
        struct ast *ast = parser_input(input_tokens);
        int status = ast->vtable->run(ast);
        if (status != 0)
            exit(2);
        xalloc_deinit();
    }
    return 0;
}
